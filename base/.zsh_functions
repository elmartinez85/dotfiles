# ============================================
# Custom Functions
# ============================================
# These functions are automatically loaded by .zshrc
# Edit this file to add your own custom functions

# ============================================
# Directory & File Management
# ============================================

# Create a directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Go up N directories (e.g., up 3)
up() {
    local d=""
    local limit="${1:-1}"
    for ((i=1; i<=limit; i++)); do
        d="../$d"
    done
    cd "$d" || return
}

# Extract any archive type
extract() {
    if [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"     ;;
            *.tar.gz)    tar xzf "$1"     ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.rar)       unrar x "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.tar)       tar xf "$1"      ;;
            *.tbz2)      tar xjf "$1"     ;;
            *.tgz)       tar xzf "$1"     ;;
            *.zip)       unzip "$1"       ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# ============================================
# Git Functions
# ============================================

# Quick commit with message
gcom() {
    git add --all
    git commit -m "$*"
}

# Quick commit and push
gcomp() {
    git add --all
    git commit -m "$*"
    git push
}

# Create a new branch and switch to it
gnb() {
    git checkout -b "$1"
}

# Delete local and remote branch
gdb() {
    git branch -d "$1"
    git push origin --delete "$1"
}

# Git clone and cd into directory
gclone() {
    git clone "$1" && cd "$(basename "$1" .git)" || return
}

# ============================================
# Development Helpers
# ============================================

# Find process using a specific port
port() {
    lsof -i ":$1"
}

# Kill process on specific port
killport() {
    lsof -ti ":$1" | xargs kill -9
}

# Create a backup of a file
backup() {
    cp "$1"{,.backup-$(date +%Y%m%d-%H%M%S)}
}

# ============================================
# Network & System Info
# ============================================

# Get all IP addresses
myips() {
    echo "Public IP:  $(curl -s ifconfig.me)"
    echo "Local IP:   $(ipconfig getifaddr en0)"
    echo "Router IP:  $(netstat -nr | grep default | awk '{print $2}' | head -n 1)"
}

# Test website response time
pingweb() {
    curl -o /dev/null -s -w "DNS: %{time_namelookup}s\nConnect: %{time_connect}s\nTotal: %{time_total}s\n" "$1"
}

# ============================================
# File Search & Content
# ============================================

# Find files by name (using fd command if available, otherwise find)
ff() {
    if command -v fd &> /dev/null; then
        command fd --type f "$1"
    else
        find . -type f -iname "*$1*"
    fi
}

# Find directories by name (renamed to avoid conflict with fd command)
fdir() {
    if command -v fd &> /dev/null; then
        command fd --type d "$1"
    else
        find . -type d -iname "*$1*"
    fi
}

# Search for text in files (using ripgrep if available, otherwise grep)
search() {
    if command -v rg &> /dev/null; then
        rg "$@"
    else
        grep -r "$@" .
    fi
}

# ============================================
# Productivity & Utilities
# ============================================

# Create a timestamped note file
note() {
    local note_file="$HOME/Documents/notes-$(date +%Y%m%d-%H%M%S).md"
    echo "# Note - $(date '+%Y-%m-%d %H:%M:%S')" > "$note_file"
    echo "" >> "$note_file"
    echo "$*" >> "$note_file"
    codium "$note_file"
}

# Weather report
weather() {
    local location="${1:-}"
    curl "wttr.in/${location}"
}

# QR code generator (encode text to QR in terminal)
qr() {
    curl "qrenco.de/$*"
}

# ============================================
# macOS Specific Functions
# ============================================

# Open current directory in Finder
finder() {
    open -a Finder "${1:-.}"
}

# Copy current directory path to clipboard
cpwd() {
    pwd | tr -d '\n' | pbcopy
    echo "Current directory path copied to clipboard"
}

# Copy file contents to clipboard
ccat() {
    if [ -f "$1" ]; then
        cat "$1" | pbcopy
        echo "File contents copied to clipboard"
    else
        echo "File not found: $1"
    fi
}

# ============================================
# Node/NPM Functions
# ============================================

# Initialize a new npm project with defaults
npminit() {
    npm init -y
}

nvm() {
  unset -f nvm node npm
  [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && . "/opt/homebrew/opt/nvm/nvm.sh"
  nvm "$@"
}

node() {
  unset -f nvm node npm
  [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && . "/opt/homebrew/opt/nvm/nvm.sh"
  node "$@"
}

npm() {
  unset -f nvm node npm
  [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && . "/opt/homebrew/opt/nvm/nvm.sh"
  npm "$@"
}

# ============================================
# Python Functions
# ============================================

# Create and activate a virtual environment
venv() {
    python3 -m venv venv
    source venv/bin/activate
}

# Activate existing virtual environment
vact() {
    if [ -d "venv" ]; then
        source venv/bin/activate
    elif [ -d ".venv" ]; then
        source .venv/bin/activate
    else
        echo "No virtual environment found"
    fi
}

# rclone with fzf
rcfz() {
  local remote="${1:?Usage: rcfz <remote:path>}"
  local base="${remote%/}"   # strip trailing slash if provided

  # Build preview command with base expanded now (so fzf only needs to replace {})
   local preview_cmd="rclone cat ${(q)base}/{} | bat --color=always --file-name {}"

  rclone ls "$base" \
    | awk '{print $2}' \
    | fzf --preview "$preview_cmd"
}

# ============================================
# Tmux Functions
# ============================================

# Tmux session manager - create or attach to named session
# Usage: ts <session-name>
ts() {
    if [ -z "$1" ]; then
        echo "Usage: ts <session-name>"
        echo ""
        echo "Available sessions:"
        tmux list-sessions 2>/dev/null || echo "  (no active sessions)"
        return 1
    fi

    local session_name="$1"

    # Check if tmux is installed
    if ! command -v tmux &> /dev/null; then
        echo "Error: tmux is not installed"
        echo "Install with: brew install tmux"
        return 1
    fi

    # Check if we're already inside a tmux session
    if [ -n "$TMUX" ]; then
        # We're inside tmux, switch to the session
        if tmux has-session -t "$session_name" 2>/dev/null; then
            tmux switch-client -t "$session_name"
            echo "Switched to session: $session_name"
        else
            tmux new-session -d -s "$session_name"
            tmux switch-client -t "$session_name"
            echo "Created and switched to session: $session_name"
        fi
    else
        # We're outside tmux, attach or create
        if tmux has-session -t "$session_name" 2>/dev/null; then
            tmux attach-session -t "$session_name"
        else
            tmux new-session -s "$session_name"
        fi
    fi
}

# List all tmux sessions with details
tsl() {
    if ! command -v tmux &> /dev/null; then
        echo "Error: tmux is not installed"
        return 1
    fi
    tmux list-sessions 2>/dev/null || echo "No active tmux sessions"
}

# Kill a tmux session by name
tk() {
    if ! command -v tmux &> /dev/null; then
        echo "Error: tmux is not installed"
        return 1
    fi

    if [ -z "$1" ]; then
        echo "Usage: tk <session-name>"
        echo ""
        echo "Available sessions:"
        tsl
        return 1
    fi

    if tmux has-session -t "$1" 2>/dev/null; then
        tmux kill-session -t "$1"
        echo "Killed session: $1"
    else
        echo "Session not found: $1"
        return 1
    fi
}

# Kill all tmux sessions except current
tka() {
    if ! command -v tmux &> /dev/null; then
        echo "Error: tmux is not installed"
        return 1
    fi

    if [ -z "$TMUX" ]; then
        echo "Not in a tmux session. Kill all sessions? [y/N]"
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            tmux kill-server
            echo "All tmux sessions killed"
        fi
    else
        local current_session=$(tmux display-message -p '#S')
        local killed_count=0

        tmux list-sessions -F "#{session_name}" 2>/dev/null | while read -r session; do
            if [ "$session" != "$current_session" ]; then
                tmux kill-session -t "$session"
                echo "Killed session: $session"
                ((killed_count++))
            fi
        done

        echo "Kept current session: $current_session"
    fi
}

# ============================================
# Process Management
# ============================================

# Find and kill process by name (interactive)
pk() {
    if [ -z "$1" ]; then
        echo "Usage: pk <process-name>"
        return 1
    fi

    # Find matching processes (exclude grep and this function)
    local processes=$(ps aux | grep -i "$1" | grep -v grep | grep -v "pk $1")

    if [ -z "$processes" ]; then
        echo "No processes found matching: $1"
        return 1
    fi

    echo "Found processes matching '$1':"
    echo "$processes" | awk '{printf "%s\t%s\t%s\n", $2, $3, substr($0, index($0,$11))}'
    echo ""
    echo "Kill these processes? [y/N]"
    read -r response

    if [[ "$response" =~ ^[Yy]$ ]]; then
        echo "$processes" | awk '{print $2}' | xargs kill -9
        echo "Processes killed"
    else
        echo "Cancelled"
    fi
}

# Show top processes by memory usage
topmem() {
    local count="${1:-10}"
    echo "Top $count processes by memory usage:"
    ps aux | sort -nrk 4 | head -n "$count" | awk '{printf "%-8s %6s%% %6s%% %s\n", $2, $3, $4, substr($0, index($0,$11))}'
}

# Show top processes by CPU usage
topcpu() {
    local count="${1:-10}"
    echo "Top $count processes by CPU usage:"
    ps aux | sort -nrk 3 | head -n "$count" | awk '{printf "%-8s %6s%% %6s%% %s\n", $2, $3, $4, substr($0, index($0,$11))}'
}

# ============================================
# System Information
# ============================================

# Show comprehensive system info summary
sysinfo() {
    echo "╔══════════════════════════════════════════╗"
    echo "║         System Information              ║"
    echo "╚══════════════════════════════════════════╝"
    echo ""
    echo "OS:           $(sw_vers -productName) $(sw_vers -productVersion) (Build $(sw_vers -buildVersion))"
    echo "Hostname:     $(hostname)"
    echo "Architecture: $(uname -m)"
    echo "Kernel:       $(uname -r)"
    echo "Uptime:       $(uptime | awk -F'up ' '{print $2}' | awk -F',' '{print $1}')"
    echo ""
    echo "CPU:          $(sysctl -n machdep.cpu.brand_string)"
    echo "CPU Cores:    $(sysctl -n hw.ncpu) cores"
    echo ""
    echo "Memory:       $(sysctl -n hw.memsize | awk '{printf "%.2f GB\n", $1/1024/1024/1024}')"
    echo "Memory Usage: $(vm_stat | awk '/Pages active/ {printf "%.2f GB active\n", $3 * 4096 / 1024 / 1024 / 1024}')"
    echo ""
    echo "Disk Usage:   $(df -h / | awk 'NR==2 {print $5 " used (" $3 " of " $2 ")"}')"
    echo ""
    echo "Network:"
    if command -v ifconfig &> /dev/null; then
        local ip=$(ipconfig getifaddr en0 2>/dev/null || echo "Not connected")
        echo "  Local IP:   $ip"
    fi
    if command -v curl &> /dev/null; then
        local public_ip=$(curl -s --max-time 2 ifconfig.me 2>/dev/null || echo "Unable to fetch")
        echo "  Public IP:  $public_ip"
    fi
}

# Show listening ports
ports() {
    echo "Listening TCP ports:"
    echo "===================="
    sudo lsof -iTCP -sTCP:LISTEN -n -P | awk 'NR==1 || /LISTEN/ {printf "%-20s %-8s %-10s %s\n", $1, $2, $9, $10}'
}

# Show listening ports (user-level only, no sudo)
myports() {
    echo "My listening TCP ports:"
    echo "======================="
    lsof -iTCP -sTCP:LISTEN -n -P | awk 'NR==1 || /LISTEN/ {printf "%-20s %-8s %-10s %s\n", $1, $2, $9, $10}'
}

# ============================================
# AWS / Cloud Helpers
# ============================================

# Switch AWS profile with validation
awsp() {
    if [ -z "$1" ]; then
        echo "Current AWS profile: ${AWS_PROFILE:-default}"
        echo ""
        echo "Available profiles:"

        if [ -f ~/.aws/config ]; then
            grep '^\[' ~/.aws/config | sed 's/\[profile \(.*\)\]/  \1/' | sed 's/\[default\]/  default/'
        else
            echo "  (no AWS config file found)"
        fi
        return 0
    fi

    # Validate profile exists
    if [ -f ~/.aws/config ]; then
        if grep -q "^\[profile $1\]" ~/.aws/config || [ "$1" = "default" ]; then
            export AWS_PROFILE="$1"
            echo "✓ Switched to AWS profile: $1"

            # Try to show identity if AWS CLI is configured
            if command -v aws &> /dev/null; then
                echo ""
                aws sts get-caller-identity 2>/dev/null || echo "  (unable to verify identity - check credentials)"
            fi
        else
            echo "Error: Profile '$1' not found in ~/.aws/config"
            echo ""
            echo "Available profiles:"
            grep '^\[' ~/.aws/config | sed 's/\[profile \(.*\)\]/  \1/' | sed 's/\[default\]/  default/'
            return 1
        fi
    else
        echo "Error: ~/.aws/config not found"
        return 1
    fi
}

# Clear AWS profile (use default)
awsc() {
    unset AWS_PROFILE
    echo "✓ Cleared AWS profile (using default)"
}

# Show current AWS identity
whoami-aws() {
    if ! command -v aws &> /dev/null; then
        echo "Error: AWS CLI not installed"
        return 1
    fi

    echo "Current AWS Profile: ${AWS_PROFILE:-default}"
    echo ""
    aws sts get-caller-identity
}

# List AWS profiles with account info
awsls() {
    if ! command -v aws &> /dev/null; then
        echo "Error: AWS CLI not installed"
        return 1
    fi

    echo "AWS Profiles:"
    echo "============="
    echo ""

    if [ -f ~/.aws/config ]; then
        # Get all profile names
        local profiles=$(grep '^\[' ~/.aws/config | sed 's/\[profile \(.*\)\]/\1/' | sed 's/\[default\]/default/')

        for profile in $profiles; do
            echo "Profile: $profile"

            # Try to get account info
            local old_profile=$AWS_PROFILE
            export AWS_PROFILE=$profile

            local identity=$(aws sts get-caller-identity 2>/dev/null)
            if [ $? -eq 0 ]; then
                echo "$identity" | jq -r '  "  Account: " + .Account + "\n  User/Role: " + .Arn' 2>/dev/null || echo "  (identity info available but jq not installed)"
            else
                echo "  (unable to get identity - check credentials)"
            fi

            export AWS_PROFILE=$old_profile
            echo ""
        done
    else
        echo "(no AWS config file found)"
    fi
}

# Quick S3 bucket list
s3ls() {
    if ! command -v aws &> /dev/null; then
        echo "Error: AWS CLI not installed"
        return 1
    fi

    echo "S3 Buckets (profile: ${AWS_PROFILE:-default}):"
    echo "=============================================="
    aws s3 ls
}

# ============================================
# Zsh Maintenance
# ============================================

# Fix broken zsh completions (remove broken symlinks)
zsh-fix-completions() {
    echo "Checking for broken completion symlinks..."
    local broken_count=0

    for comp_dir in /opt/homebrew/share/zsh/site-functions /usr/local/share/zsh/site-functions; do
        if [ -d "$comp_dir" ]; then
            echo "Checking: $comp_dir"

            for file in "$comp_dir"/_*; do
                if [ -L "$file" ] && [ ! -e "$file" ]; then
                    echo "  ✗ Broken: $(basename "$file") -> $(readlink "$file")"
                    rm -f "$file"
                    ((broken_count++))
                fi
            done
        fi
    done

    if [ $broken_count -eq 0 ]; then
        echo "✓ No broken completion symlinks found"
    else
        echo ""
        echo "✓ Removed $broken_count broken completion symlink(s)"
        echo "  Run 'refresh' to reload your shell"
    fi
}
